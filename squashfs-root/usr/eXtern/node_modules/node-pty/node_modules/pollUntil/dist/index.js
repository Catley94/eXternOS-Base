'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _Promise = _interopDefault(require('babel-runtime/core-js/promise'));

function pollUntil(fn) {
  var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var timeout = arguments.length <= 2 || arguments[2] === undefined ? 3000 : arguments[2];
  var pollInterval = arguments.length <= 3 || arguments[3] === undefined ? 200 : arguments[3];

  if (typeof fn !== 'function') {
    throw new Error('Polling function argumentmissing');
  }

  if (typeof args === 'number') {
    pollInterval = timeout;
    timeout = args;
    args = [];
  }

  var s1 = void 0;
  var s2 = void 0;

  function clearSchedulers() {
    clearTimeout(s1);
    clearTimeout(s2);
  }

  var poller = new _Promise(function (resolve) {
    (function poll() {
      var result = fn.apply(this, args);
      if (result) {
        resolve(result);
      } else {
        s1 = setTimeout(poll, pollInterval);
      }
    })();
  });

  var timebomb = new _Promise(function (resolve) {
    s2 = setTimeout(function () {
      resolve(false);
    }, timeout);
  });

  return _Promise.race([poller, timebomb]).then(function (res) {
    clearSchedulers();
    return _Promise.resolve(res);
  }).catch(function (err) {
    clearSchedulers();
    throw new Error(err);
  });
}

module.exports = pollUntil;
//# sourceMappingURL=index.js.map
